#!/usr/bin/perl
use strict;
use warnings;
use File::Find;

use Cwd;
use 5.010;

my $root = getcwd;

chdir 'obj' if -d 'obj';  # Look in the obj dir if we have one

my ($bsdwrapper) = grep { -e } 'Makefile.bsd-wrapper1',
    "$root/Makefile.bsd-wrapper1";

die "Couldn't find Makefile.bsd-wrapper1" unless $bsdwrapper;

my %proper_page = (
    'utils/splain' => 'splain',
);
my %skip_page = map { $_ => 1 } qw(
    json_pp
    ptar
    ptardiff
    ptargrep
    shasum
    zipdetails


    Changes
    HACKERS
    INSTALL
    TODO
    buildperl
    exetype
    installhtml
    make_patchnum
    mkppport
    perlcn
    perldtrace
    perlebcdic
    perlglobbat
    perljp
    perlko
    perltw
    pl2bat
    ppporth
    regenerate
    runperlbat
    soak

    perlaix
    perlamiga
    perlbs2000
    perlce
    perlcygwin
    perldgux
    perldos
    perlfreebsd
    perlhaiku
    perlhpux
    perlhurd
    perlirix
    perllinux
    perlmacos
    perlmacosx
    perlnetware
    perlos2
    perlos390
    perlos400
    perlplan9
    perlqnx
    perlricos
    perlsolaris
    perltrue64
    perlvms
    perlvos
    perlwin32
    Module::Build::Platform::Amiga
    Module::Build::Platform::EBCDIC
    Module::Build::Platform::MPEiX
    Module::Build::Platform::MacOS
    Module::Build::Platform::RiscOS
    Module::Build::Platform::VMS
    Module::Build::Platform::VOS
    Module::Build::Platform::Windows
    Module::Build::Platform::aix
    Module::Build::Platform::cygwin
    Module::Build::Platform::darwin
    Module::Build::Platform::os2
    OS2::DLL
    OS2::ExtAttr
    OS2::PrfDB
    OS2::Process
    OS2::REXX
    Sys::Syslog::Win32
    Win32
    Win32API::File
);

open my $fh, '<', $bsdwrapper or die "Couldn't open $bsdwrapper: $!";

# Find the right section
while (<$fh>) { last if /for page sect file in/ }

my %old_pod;
while (<$fh>) {
    my ($page, $section, $file, $slash) = split;
    $old_pod{ $page } = {
        file    => $file,
        section => $section,
    };
    last unless $slash;
}
close $fh;


my %new_pod;
my $wanted = sub {
    my $look_in = shift;
    if ($_ eq 'Porting') {
        $File::Find::prune = 1;
        return;
    }

    return unless -f $_;
    my $file = $File::Find::name;

    return if /\.t(?:xt)$/; # skip txt files and tests
    return if /\.orig$/;    # skip patch files
    return if $file =~ m{/t/}; # or files in test dirs
    return if $file =~ m{/ext/}; # or in an ext dir
    return if $file =~ m{symbian}; # don't need that

    # Remove leading ./ and optional obj/
    $file =~ s{^\./(?:obj/)?}{};

    # Don't find things in the source, only installed
    return if $look_in ne 'dist' && $file =~ m{^dist/};
    return if $look_in ne 'cpan' && $file =~ m{^cpan/};

    # Nothing in here is useful and can hide correct source of manuals
    return if $file =~ m{^regen/};
    return if $file =~ m{^hints/};
    return if $file =~ m{^Cross/};

    my $page;

    if ($proper_page{$file}) {
        $page = $proper_page{$file};
    }
    elsif ($file =~ m{pod/(perl\w+).pod}) {
        $page = $1;
    }
    else {
        open my $fh, '<', $_ or die "Couldn't open $File::Find::name";
        my $found_pod = 0;

        while (<$fh>) {
            if (/^=head1\s+NAME/) {
                $found_pod = 1;
                next;
            }

            next unless $found_pod;
            last if /^=\w+/;

            if (/^(\S+)/) {
                $page = $1;
                last;
            }
        }

        return unless $found_pod;
        return unless $page;

        $page =~ s/\.p[lm]$//;
        $page =~ s/^\w\<//;    # strip possible B<
        $page =~ s/[^\w:]//g;
    }

    return unless $page;
    return if $skip_page{$page};

    my $section
        = exists $old_pod{$page} ? $old_pod{$page}{section}
        : $file =~ /\.pm$/       ? '3p'
        :                          '1';

    $new_pod{$page} = {
        file    => $file,
        section => $section,
    };
};

foreach my $look_in ('cpan', 'dist', '.') {
    find( sub{ $wanted->( $look_in ) }, $look_in);
}

my $changed = 0;
my @file_list;
foreach my $page (sort { 
    $new_pod{$a}{section} cmp $new_pod{$b}{section}
        || lc($a) cmp lc($b) } keys %new_pod) {
    unless ($old_pod{$page}) {
        say "New page: $page [$new_pod{$page}{file}][$new_pod{$page}{section}]";
        $changed++;
    }
    push @file_list, [ $page, @{ $new_pod{$page} }{qw( section file )} ];
}

foreach my $page (sort { 
    $old_pod{$a}{section} cmp $old_pod{$b}{section}
        || $a cmp $b } keys %old_pod) {
    unless ($new_pod{$page}) {
        say "Lost page: $page [$old_pod{$page}{file}][$old_pod{$page}{section}]";
        $changed++;
    }
}

unless ($changed) {
    say "No changes";
    exit;
}

my $num_tabs   = 5;
my $tab_length = 8;
open my $ofh, '>', $bsdwrapper . '.new' or die $!;
open my $ifh, '<', $bsdwrapper          or die $!;
while (<$ifh>) {
    if (/for page sect file in/) {
        print $ofh $_;

        foreach my $i ( 0 .. $#file_list ) {
            my $tabs = (
                (     ( $tab_length * $num_tabs )
                    - ( length( $file_list[$i][0] . $file_list[$i][1] ) + 5 )
                ) / $tab_length
            );
            $tabs = 1 if $tabs < 1;
            $tabs++ if $tabs != int $tabs;
            $tabs = "\t" x int($tabs);

            my $fmt = "    %s %s$tabs%s";
            $fmt .= $i == $#file_list ? "\n" : " \\\n";
            printf $ofh $fmt, @{ $file_list[$i] };
        }

        while (<$ifh>) { last unless m{\\$} }
        next;
    }
    print $ofh $_;
}
close $ifh;
close $ofh;

say "Created $bsdwrapper.new";
