--- ./regexec.c.orig	Fri Aug 21 13:24:03 2015
+++ ./regexec.c	Wed Apr 20 11:29:24 2016
@@ -7887,6 +7887,10 @@ S_reghopmaybe3(U8* s, SSize_t off, const U8* lim)
             if (UTF8_IS_CONTINUED(*s)) {
                 while (s > lim && UTF8_IS_CONTINUATION(*s))
                     s--;
+                if (! UTF8_IS_START(*s)) {
+                    dTHX;
+                    Perl_croak(aTHX_ "Malformed UTF-8 character (fatal)");
+                }
 	    }
             /* XXX could check well-formedness here */
 	}
@@ -7913,6 +7917,10 @@ S_reghopmaybe3(U8* s, SSize_t off, const U8* lim)
 */
 
 static void
+                if (! UTF8_IS_START(*s)) {
+                    dTHX;
+                    Perl_croak(aTHX_ "Malformed UTF-8 character (fatal)");
+                }
 S_setup_eval_state(pTHX_ regmatch_info *const reginfo)
 {
     MAGIC *mg;
@@ -7944,6 +7952,10 @@ S_setup_eval_state(pTHX_ regmatch_info *const reginfo)
         /* PL_reg_curpm is a fake PMOP that we can attach the current
          * regex to and point PL_curpm at, so that $1 et al are visible
          * within a /(?{})/. It's just allocated once per interpreter the
+                if (! UTF8_IS_START(*s)) {
+                    dTHX;
+                    Perl_croak(aTHX_ "Malformed UTF-8 character (fatal)");
+                }
          * first time its needed */
         Newxz(PL_reg_curpm, 1, PMOP);
 #ifdef USE_ITHREADS
--- ./t/re/pat.t.orig	Sat Jan 24 07:03:59 2015
+++ ./t/re/pat.t	Wed Apr 20 11:29:24 2016
@@ -20,7 +20,7 @@ BEGIN {
     require './test.pl';
 }
 
-plan tests => 726;  # Update this when adding/deleting tests.
+plan tests => 727;  # Update this when adding/deleting tests.
 
 run_tests() unless caller;
 
@@ -1602,6 +1602,22 @@ EOP
 		ok(1, "did not crash");
 		ok($match, "[bbb...] resolved as character class, not subscript");
 	}
+
+        {   # Test that we handle some malformed UTF-8 without looping [perl
+            # #123562]
+
+            my $code='
+                BEGIN{require q(test.pl);}
+                use Encode qw(_utf8_on);
+                my $malformed = "a\x80\n";
+                _utf8_on($malformed);
+                watchdog(3);
+                $malformed =~ /(\n\r|\r)$/;
+                print q(No infinite loop here!);
+            ';
+            fresh_perl_like($code, qr/Malformed UTF-8 character/, {},
+                "test that we handle some UTF-8 malformations without looping" );
+        }
 } # End of sub run_tests
 
 1;
