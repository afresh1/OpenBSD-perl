From dd6885360b15e763e0706dc28555eea328de432d Mon Sep 17 00:00:00 2001
From: Niko Tyni <ntyni@debian.org>
Date: Fri, 18 Nov 2016 18:36:34 +0200
Subject: [PATCH] Configure: fix garbage filtering with 80-bit long doubles

The test had several problems that resulted in the excess
bytes not getting zeroed out. This caused random contents in
$Config{longdblinfbytes}, observed on Debian with GCC 6.2.0 (but not
5.4.1).

Bug-Debian: https://bugs.debian.org/844752
---
 Configure | 14 ++++++--------
 1 file changed, 6 insertions(+), 8 deletions(-)

diff --git a/Configure ./Configure
index 6a3d617684..f561a87e19 100755
--- a/Configure
+++ ./Configure
@@ -20661,8 +20661,8 @@ $cat >try.c <<EOP
 #define DOUBLESIZE $doublesize
 #$d_longdbl HAS_LONG_DOUBLE
 #ifdef HAS_LONG_DOUBLE
-#define LONGDBLSIZE $longdblsize
-#define LONGDBLKIND $longdblkind
+#define LONG_DOUBLESIZE $longdblsize
+#define LONG_DOUBLEKIND $longdblkind
 #endif
 #$i_math I_MATH
 #ifdef I_MATH
@@ -20699,16 +20699,14 @@ int main(int argc, char *argv[]) {
 #ifdef HAS_LONG_DOUBLE
    long double ldinf = (long double)exp(1e9);
    long double ldnan = (long double)sqrt(-1.0);
-#endif
-  if (argc == 2) {
-    switch (argv[1][0]) {
-    case '1': bytes(&dinf, sizeof(dinf)); break;
-    case '2': bytes(&dnan, sizeof(dnan)); break;
-#ifdef HAS_LONG_DOUBLE
 # if LONG_DOUBLEKIND == 3 || LONG_DOUBLEKIND == 4
 /* the 80-bit long doubles might have garbage in their excess bytes */
     memset((char *)&ldinf + 10, '\0', LONG_DOUBLESIZE - 10);
 # endif
+  if (argc == 2) {
+    switch (argv[1][0]) {
+    case '1': bytes(&dinf, sizeof(dinf)); break;
+    case '2': bytes(&dnan, sizeof(dnan)); break;
     case '3': bytes(&ldinf, sizeof(ldinf)); break;
     case '4': bytes(&ldnan, sizeof(ldnan)); break;
 #endif
-- 
2.12.2

